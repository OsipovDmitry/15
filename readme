Требования:
- динамический выбор поля от 2х2 до 10х10;
- визуализация в 3D. Динамическое попиксельное освещение для поля и плашек;
- обзор камерой - движение мышки с зажатой правой кнопкой, приближение/отдаление - колесико;
- при старте плашки смещаются случайным образом. Любая предложенная комбинация имеет решение;
- для плашек подготовлена красивая 3D модель. Дабы не захломлять проект дополнительными библиотеками по импорту 3D форматов, вершины и индексы всей игровой геометрии вынесены в специальный файл meshdata.h;
- по клику левой клавишей мыши на плашку, перемещается ВЕСЬ РЯД ИЛИ СТОЛБЕЦ, если в нем присутсвует пустое поле(не обязательно перемещать по одной плашке за ход!);

Нефункциональные требования:
- C++11, Qt (Cross platform)
- OpenGL 3.3. Было принято решение писать именно на OpenGL, а не OSG, чтобы продемонстрировать навыки рыботы на низком уровне;
- Cборка:
    1) Удобнее всего из QtCreator. Просто жмем на зеленый треугольник - приложение соберется и зупустится;
    2) Из терминала. qmake; make(nmake/другой компилятор). В этом случае придется прописать путь к библиотекам Qt в переменных окружения или подкинуть их рядом с собранным приложением.

О проекте:
    Попытался реализовать полноценное игровое приложение с меню, выбором сложности, возможностью выхода из игры. Все приложение реализовано в виде одного модуля. Все заголовочные и исходные файлы можно разделить на три смысловые части:
 1) файлы начинающиеся с graphics*. Тут хранится группа классов в пространстве имен graphics. Это что-то вроде простого графического движка на OpenGL 3.3. Тут присутствуют такие классы как Mesh(обертка над вершинным и индексным VBO и одним VAO), Material(обертка над текстурой), Model(контейнер для Mesh + Material, а так же позиционированием на сцене), Scene(графическая сцена, поделенная на несколько слоев), SceneLayer(слой сцены, тут непосредственно хранится шейдер и список моделей) и Controller(основной класс графического модуля, являющийся менеджером графических ресурсов и оберткой для OpenGL контекста).
 2) Группа классов в пространстве имен game. Сюда входит класс GameWidget - наследник QOpenGLWidget, который занимается инициализацией и уведомлением графического контроллера о событиях с окном. Так же здесь класс AbstractGame - являющийся интерйейсом интерфейсом для произвольной игры и посредником между GameWidget и игрой;
 3) Группа классов Game15* в пространстве имен game15. Здесь все классы отвечающие за работу пятнашек.

    Тестировал приложение на Ubuntu и Windows10(64bit). Все прекрасно работало.

 

